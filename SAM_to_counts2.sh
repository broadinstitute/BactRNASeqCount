#!/bin/sh

#### Path to SAM sorted by ID, NOT coordinate
SAM=$1
#### Path to feature file generated by gff_parse4.sh
FEATURE_FILE=$2
#### Path to directory containing SAM_PARSE and FEATURE_COUNT_COORDS
SCRIPT_DIR=$3"/"
#### Path to directory in which to write temporary files
TEMP_PATH=$4"/"
#### Full dir path and name to output file
COUNT_FILE=$5

########  function for extracting options from command line
 
		extract_option ()
		{
			option_name=$1 
			shift
			default=$1
			shift 
			echo $@ | awk -v def=$default -v name=$option_name '{
		
				for(i=1; i < NF+1; i++)
				{
					if(i==1)			# intitalize to $default in case no option found
						print def
					if($i==name)
						print $(i+1)
				}
			}' | tail -1
		}

###############################  extract and checkpoint options  ##############################

options=$@

### options to be used in this scripts or passed to SAM_PARSE and/or FEATURE_COUNT_COORDS, default values indicated in 3rd position
# if aligner returns alignments on reverse strand, set to Y
STRAND_REV=`extract_option -STRAND_REV N $options`
# to remove all but one instance of identical coordinate pairs, set to Y
UNIQ_READS=`extract_option -UNIQ_READS N $options`
# to count only properly paired reads, set to Y
PAIRED_ONLY=`extract_option -paired_only N $options`

### name of metrics file to be generated
MET_FILE=`echo $COUNT_FILE | sed 's/.counts/.mets/g'`

ROOT=`echo $SAM | rev | cut -d"/" -f1 | rev | sed 's/.sam//g'`
COORD_FILE=$TEMP_PATH"/"$ROOT"_coords.txt"
COORD_UNIQ_FILE=$TEMP_PATH"/"$ROOT"_coords_uniq.txt"
COUNT_TEMP_FILE=$TEMP_PATH"/"$ROOT"_counts_temp.txt"
ACC_FILE=$TEMP_PATH"/"$ROOT"_ACC.txt"
FEATURE_FILE_PARSED=$TEMP_PATH"/"$ROOT"_parsed.gff"

cat $FEATURE_FILE | grep -v "#" |  awk '{print $1}' | sort | uniq > $ACC_FILE

##### pulling alignment coordinates out of $SAM to generate $COORD_FILE and $MET_FILE
echo "Pulling out coordinates and metrics..."
echo "$SCRIPT_DIR"SAM_PARSE" $SAM $COORD_FILE $MET_FILE $ACC_FILE $STRAND_REV"
$SCRIPT_DIR"SAM_PARSE" $SAM $COORD_FILE $MET_FILE $ACC_FILE $STRAND_REV 

##### if $UNIQ_READS set to Y, resolve identical coordinate pairs
if [ $UNIQ_READS == "Y" ];then

	echo "Finding unique coordinates..."
	$COORD_FILE | awk '{split($NF, ar, ":");$NF=ar[1]":a"r[2]":"ar[3]; print $0}' | sort | uniq  > $COORD_UNIQ_FILE
	cat $COORD_UNIQ_FILE > $COORD_FILE

fi

##### remove headers and replace blanks with "_" in feature file
cat $FEATURE_FILE | grep -v "#" | sed 's/ /_/g' > $FEATURE_FILE_PARSED

##### assign counts to all features in $FEATURE_FILE_PARSED using $COORD_FILE and output to $COUNT_TEMP_FILE
echo "Generating counts for features..."
echo "$SCRIPT_DIR"FEATURE_COUNT_COORDS" $COORD_FILE $FEATURE_FILE_PARSED $MET_FILE $ACC_FILE $PAIRED_ONLY > $COUNT_TEMP_FILE"
$SCRIPT_DIR"FEATURE_COUNT_COORDS" $COORD_FILE $FEATURE_FILE_PARSED $MET_FILE $ACC_FILE $PAIRED_ONLY > $COUNT_TEMP_FILE

##### parse $COUNT_TEMP_FILE to generate $COUNT_FILE
cat $COUNT_TEMP_FILE | grep -v "#" | awk '{

											y=split($1, ar, ";")
											h=split(ar[y], tr, ":")
											acc=tr[h]
									
											for(i=1; i < y+1; i++)
											{
												split(ar[i], pr, "=")
												if(pr[1]=="full_tag")
												{
													if($NF=="AS")
														pr[2]="AS_"pr[2]
													printf "%s:%s\t%s\t%.0f\n" ,pr[2], acc, acc, $2
												}
											}
										}'  > $COUNT_FILE
								
	
echo "Generated $COUNT_FILE and $MET_FILE..."							
ls -lrt $COUNT_FILE
ls -lrt $MET_FILE
   
